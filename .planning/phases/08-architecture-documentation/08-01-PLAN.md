---
phase: 08-architecture-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/phases/08-architecture-documentation/DATA-STORAGE.md
  - .planning/phases/08-architecture-documentation/INSTANCE-CONFIG.md
autonomous: true

must_haves:
  truths:
    - "Vercel KV key structure is fully documented with prefix patterns, complete key examples, and instance isolation explanation"
    - "Booking data format is documented with nested object schema, field types, constraints, and concrete multi-booking examples"
    - "Empty states and edge cases are documented (no bookings, empty dates, date cleanup on delete)"
    - "Read-modify-write update pattern is explicitly documented with concurrency implications"
    - "All environment variables are documented with purpose, format, example values, and validation behavior"
    - "Per-instance differences are documented showing how INSTANCE_SLUG creates separate data namespaces"
    - "Fallback configuration is documented with exact default values"
  artifacts:
    - path: ".planning/phases/08-architecture-documentation/DATA-STORAGE.md"
      provides: "Complete Vercel KV storage schema documentation"
      min_lines: 120
    - path: ".planning/phases/08-architecture-documentation/INSTANCE-CONFIG.md"
      provides: "Environment variable and instance configuration documentation"
      min_lines: 100
  key_links:
    - from: "DATA-STORAGE.md"
      to: "INSTANCE-CONFIG.md"
      via: "INSTANCE_SLUG determines KV key prefix"
      pattern: "instance:\\{slug\\}"
    - from: "DATA-STORAGE.md"
      to: "api/bookings/index.js"
      via: "Documents the storage patterns implemented in this file"
      pattern: "read-modify-write"
---

<objective>
Document the data storage schema (Vercel KV key structure, booking data format) and instance configuration (environment variables, per-instance settings) as two foundational architecture reference documents.

Purpose: These two documents form the foundation for all other architecture docs. DATA-STORAGE.md defines HOW data is stored and keyed. INSTANCE-CONFIG.md defines how instances are configured and differentiated. Both are referenced by API contracts, state management, and polling docs.

Output: Two markdown files in the phase directory -- DATA-STORAGE.md (ARCH-01) and INSTANCE-CONFIG.md (ARCH-05).
</objective>

<execution_context>
@/Users/clintonweekes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clintonweekes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-architecture-documentation/08-RESEARCH.md

Source code to extract from (read these for exact implementation details):
@api/config.js
@api/bookings/index.js
@api/bookings/update.js
@api/_lib/security.js
@src/services/api.js
@src/context/ConfigContext.jsx
@.env.local.example

Phase 6 reference (data structures already documented):
@.planning/phases/06-code-extraction/FILE-MANIFEST.md (Data Structures section)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DATA-STORAGE.md (ARCH-01)</name>
  <files>.planning/phases/08-architecture-documentation/DATA-STORAGE.md</files>
  <action>
Create a comprehensive data storage schema document by reading the actual API source code (api/bookings/index.js, api/bookings/update.js, api/config.js, api/_lib/security.js) and the FILE-MANIFEST.md Data Structures section.

Document these sections:

1. **Storage Backend** -- Vercel KV (Redis-compatible). Technology-neutral: describe as key-value store with JSON values. No TTL on data keys (persist indefinitely).

2. **Key Structure** -- Document the complete key namespace:
   - Pattern: `instance:{slug}:{resource}`
   - Config key: `instance:{slug}:config` (e.g., `instance:cps-software:config`)
   - Bookings key: `instance:{slug}:bookings` (e.g., `instance:cps-software:bookings`)
   - Rate limit key: `ratelimit:{ip}` (e.g., `ratelimit:203.0.113.1`) with TTL 120s
   - Instance isolation: different INSTANCE_SLUG values create completely separate namespaces

3. **Config Data Schema** -- Document the config object stored at `instance:{slug}:config`:
   - Fields: slug (string), title (string), users (array of {name, key, colorIndex?}), createdAt (ISO 8601)
   - User object: name (string, display name), key (string, single letter keyboard shortcut), colorIndex (optional integer 0-5)
   - Include concrete example with the actual cps-software users (Jack/j, Bonnie/b, Giuliano/g, John/h, Rue/r, Joel/l)
   - Note: key letters avoid conflicts (John uses 'h' because 'j' is taken by Jack)

4. **Bookings Data Schema** -- Document the nested bookings object:
   - Top-level: `{ [dateKey: string]: { [timeKey: string]: Booking } }`
   - dateKey format: YYYY-MM-DD with regex `/^\d{4}-\d{2}-\d{2}$/`
   - timeKey format: HH:00 (24-hour) with regex `/^\d{2}:00$/`
   - Booking object: `{ user: string (max 100 chars), duration: integer (1-8) }`
   - Include multi-booking example showing multiple dates with multiple bookings

5. **Multi-Hour Booking Representation** -- Only ONE record at start time. Duration field indicates occupied slots. Example: booking at 07:00 with duration 3 occupies 07:00, 08:00, 09:00 but only stores one record at "07:00".

6. **Empty States**:
   - No bookings at all: `{}`
   - Date with no bookings: dateKey absent from object
   - All bookings deleted for a date: dateKey removed (cleanup in delete handler)

7. **Update Pattern** -- Read-modify-write on entire bookings object:
   - Read: `kv.get(key)` fetches entire JSON object
   - Modify: Add/update/delete in memory
   - Write: `kv.set(key, bookings)` replaces entire object
   - No partial updates, no TTL
   - Concurrency note: No locking. Last write wins. Acceptable for low-concurrency booking app.

8. **Date/Time Format Reference** -- Consolidated format table:
   - Storage dateKey: YYYY-MM-DD
   - Storage timeKey: HH:00 (24-hour, zero-padded)
   - Display date: "Wednesday, February 14, 2026" (long format)
   - Display time: "7:00 AM" (12-hour)
   - Short date: "Wed, Feb 14" (week view)
   - Timezone: All storage in Queensland time (AEST, UTC+10). NSW display adds +1h but storage unchanged.

Follow the technology-neutral principle: describe WHAT is stored and HOW it is structured, not React/Vercel-specific implementation details. A Rails developer using PostgreSQL should be able to design equivalent storage from this document.

Do NOT include React-specific terms (useState, useEffect, props, hooks).
  </action>
  <verify>
Verify the document by checking:
1. File exists and has 120+ lines
2. Contains all key patterns (config, bookings, ratelimit)
3. Contains concrete JSON examples with real data shapes
4. Contains regex validation patterns for dateKey and timeKey
5. Contains empty state documentation
6. Contains read-modify-write pattern description
7. No React-specific terminology present (grep for useState, useEffect, props)
  </verify>
  <done>DATA-STORAGE.md exists with complete KV key structure, booking data schema with constraints, multi-hour booking representation, empty states, update pattern, and date/time format reference -- all technology-neutral with concrete examples from production data shapes.</done>
</task>

<task type="auto">
  <name>Task 2: Create INSTANCE-CONFIG.md (ARCH-05)</name>
  <files>.planning/phases/08-architecture-documentation/INSTANCE-CONFIG.md</files>
  <action>
Create a comprehensive instance configuration document by reading .env.local.example, api/config.js, src/context/ConfigContext.jsx, and src/services/api.js.

Document these sections:

1. **Environment Variables** -- Table with all variables:
   - `KV_REST_API_URL` (required): Vercel KV database URL. Format: HTTPS URL. Example: `https://abc123.kv.vercel-storage.com`
   - `KV_REST_API_TOKEN` (required): Vercel KV access token. Format: token string.
   - `INSTANCE_SLUG` (required, has default): Instance identifier. Format: lowercase alphanumeric + hyphens. Default: "cps-software". Determines which KV keys to read/write.
   - `VITE_USE_API` (optional): Enable API backend. Format: "true" or "false". Default: "true". When "false", app uses localStorage fallback (no server communication).

2. **Instance Isolation** -- How INSTANCE_SLUG creates separate data spaces:
   - Each slug creates separate KV key namespaces
   - `cps-software` reads from `instance:cps-software:*`
   - A different slug reads from its own namespace
   - No data sharing between instances
   - Same KV database can host multiple instances (different key prefixes)

3. **Config Object Schema** -- What gets stored and returned from /api/config:
   - Fields: slug, title, users[], createdAt
   - User object: { name: string, key: string, colorIndex?: number (0-5) }
   - Key assignment rules: single letter, unique per instance, avoids conflicts (document the John='h' and Joel='l' convention)

4. **Default/Fallback Configuration** -- Document the exact hardcoded fallback:
   - Triggered when: API returns null, API errors, VITE_USE_API=false
   - Exact values: slug="cps-software", title="CPS Software Booking", 6 users with specific key assignments
   - List all 6 users with their exact key mappings
   - Behavior: app always works even without API (fallback ensures functionality)

5. **Config Loading Order** -- Critical initialization sequence:
   - Step 1: App starts, checks if API enabled (VITE_USE_API)
   - Step 2: If API enabled, fetch config from GET /api/config
   - Step 3: If config returned, use it; if null or error, use fallback
   - Step 4: Config available globally to entire application
   - Step 5: THEN bookings can be loaded (config must be available first for user validation)
   - WHY ORDER MATTERS: User validation during booking requires config.users list

6. **Per-Instance Customization** -- What differs between instances:
   - Title (display name)
   - Users (names, keyboard shortcuts, optional color assignments)
   - Data (separate bookings namespace via slug)
   - What does NOT differ: operating hours (6 AM - 10 PM), duration options (1-8), polling interval (7s), security rules

7. **Validation** -- What happens on invalid/missing config:
   - Missing KV_REST_API_URL + KV_REST_API_TOKEN: API calls fail, falls back to localStorage mode
   - Missing INSTANCE_SLUG: defaults to "cps-software"
   - Invalid config from KV: falls back to hardcoded default
   - No startup crash on missing config (graceful degradation)

Follow technology-neutral principles. A Rails developer should understand what configuration their app needs and how instances differ.
  </action>
  <verify>
Verify the document by checking:
1. File exists and has 100+ lines
2. Contains environment variable table with all 4 variables
3. Contains fallback config with exact 6 users and key assignments
4. Contains config loading order with explicit sequence
5. Contains instance isolation explanation
6. No React-specific terminology (grep for useState, useEffect, ConfigContext, ConfigProvider)
  </verify>
  <done>INSTANCE-CONFIG.md exists with all environment variables documented, instance isolation explained, fallback configuration with exact values, config loading order with WHY it matters, per-instance customization scope, and validation/error handling -- all technology-neutral.</done>
</task>

</tasks>

<verification>
Phase-level checks for this plan:
1. Both documents exist in .planning/phases/08-architecture-documentation/
2. DATA-STORAGE.md covers ARCH-01 requirements (KV key structure, booking data format, field types)
3. INSTANCE-CONFIG.md covers ARCH-05 requirements (environment variables, per-instance settings, instance differences)
4. Documents cross-reference each other where appropriate (INSTANCE_SLUG -> KV key prefix)
5. No React-specific terminology in either document
6. All data shapes include concrete JSON examples from production
7. All formats include regex validation patterns
</verification>

<success_criteria>
- DATA-STORAGE.md is a complete reference for Vercel KV schema that a Rails developer could use to design equivalent PostgreSQL storage
- INSTANCE-CONFIG.md is a complete reference for environment setup and instance customization
- Both documents follow technology-neutral language (WHAT/WHY, not HOW React does it)
- Both documents include concrete examples with real production data shapes
- ARCH-01 and ARCH-05 requirements fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/08-architecture-documentation/08-01-SUMMARY.md`
</output>

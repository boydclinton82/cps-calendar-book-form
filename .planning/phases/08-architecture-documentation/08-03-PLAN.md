---
phase: 08-architecture-documentation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/phases/08-architecture-documentation/POLLING-SYNC.md
  - .planning/phases/08-architecture-documentation/STATE-MANAGEMENT.md
autonomous: true

must_haves:
  truths:
    - "Polling interval (7 seconds), enable/disable conditions, and error handling behavior are documented"
    - "Conflict detection via polling is documented (optimistic update + server truth + rollback)"
    - "Manual sync capability is documented with when and why it triggers"
    - "Complete application state shape is documented (bookings, config, UI state, timezone preference)"
    - "State initialization order is documented with explicit dependency chain (config before bookings)"
    - "Optimistic update pattern is documented with rollback mechanism for all three operations (create, update, delete)"
    - "All state triggers are documented (what causes state to change and what happens)"
  artifacts:
    - path: ".planning/phases/08-architecture-documentation/POLLING-SYNC.md"
      provides: "Polling mechanism documentation with timing, triggers, and conflict handling"
      min_lines: 100
    - path: ".planning/phases/08-architecture-documentation/STATE-MANAGEMENT.md"
      provides: "Application state documentation with flows, triggers, and update patterns"
      min_lines: 150
  key_links:
    - from: "POLLING-SYNC.md"
      to: "STATE-MANAGEMENT.md"
      via: "Polling updates replace local bookings state"
      pattern: "replace.*local|sync.*state"
    - from: "STATE-MANAGEMENT.md"
      to: "src/hooks/useBookings.js"
      via: "Documents the state management implemented in this file"
      pattern: "optimistic|rollback|triggerSync"
    - from: "POLLING-SYNC.md"
      to: "src/hooks/usePollingSync.js"
      via: "Documents the polling mechanism implemented in this file"
      pattern: "7000|7.second|interval"
---

<objective>
Document the polling sync mechanism and application state management as two tightly coupled architecture reference documents.

Purpose: Polling and state management are deeply intertwined -- polling IS the mechanism that keeps state synchronized across multiple users. Documenting them together in one plan ensures consistency. POLLING-SYNC.md covers the real-time sync mechanism (ARCH-03). STATE-MANAGEMENT.md covers what state exists and how it flows (ARCH-04).

Output: Two markdown files in the phase directory -- POLLING-SYNC.md (ARCH-03) and STATE-MANAGEMENT.md (ARCH-04).
</objective>

<execution_context>
@/Users/clintonweekes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clintonweekes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-architecture-documentation/08-RESEARCH.md

Source code to extract from:
@src/hooks/usePollingSync.js
@src/hooks/useBookings.js
@src/hooks/useConfig.js
@src/hooks/useHourlyRefresh.js
@src/hooks/useKeyboard.js
@src/services/api.js
@src/context/ConfigContext.jsx
@src/utils/time.js
@src/utils/storage.js
@src/App.jsx

Phase 6 reference:
@.planning/phases/06-code-extraction/FILE-MANIFEST.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create POLLING-SYNC.md (ARCH-03)</name>
  <files>.planning/phases/08-architecture-documentation/POLLING-SYNC.md</files>
  <action>
Create a comprehensive polling sync document by reading src/hooks/usePollingSync.js, src/hooks/useBookings.js, and src/services/api.js.

Document these sections:

1. **Sync Strategy Overview**
   - Approach: Client-side polling (pull-based, not push-based)
   - Why polling (not WebSockets): Simple implementation for low-concurrency multi-user booking app. Acceptable latency (max 7 seconds to see other users' changes).
   - Rails alternative note: Could replace with Action Cable (WebSockets) for push-based real-time updates. Polling pattern still valid for simplicity.

2. **Polling Configuration**
   - Interval: 7000ms (7 seconds) -- hardcoded constant POLLING_INTERVAL
   - Enabled when: API mode is enabled (VITE_USE_API=true)
   - Disabled when: localStorage fallback mode (VITE_USE_API=false)
   - No configuration endpoint -- interval is fixed in client code

3. **Polling Lifecycle**
   - START: Polling begins when the application loads (after initial data fetch completes)
   - TICK: Every 7 seconds, fetch all bookings from GET /api/bookings
   - UPDATE: If data returned is not null, replace entire local bookings state with server data
   - STOP: Polling stops when application unmounts (cleanup)
   - No "smart" diffing -- entire state is replaced on every poll
   - This is intentional: simple replacement catches all changes (creates, updates, deletes by other users)

4. **Error Handling**
   - Polling errors are NON-FATAL
   - On fetch error: log warning to console, do NOT interrupt user, do NOT show error UI
   - Failed polls do NOT stop the timer (next poll happens in 7 seconds)
   - No exponential backoff (simple fixed interval)
   - No retry logic for individual failed polls
   - Rationale: Occasional network blips shouldn't break the app. User sees stale data for at most 7 more seconds.

5. **Manual Sync (triggerSync)**
   - Exposed function that triggers an immediate fetch outside the polling cycle
   - Used AUTOMATICALLY after failed create/update/delete operations (to rollback optimistic updates)
   - Also available for manual refresh scenarios
   - Executes same fetch logic as polling tick
   - Does NOT reset the polling timer (next scheduled tick still fires at its original time)

6. **Conflict Detection and Resolution**
   - No explicit client-side conflict detection during polling
   - Strategy: "Server is truth" -- whatever the server returns replaces local state
   - Conflict scenario (documented step by step):
     a. User A and User B both see slot 07:00 as available
     b. User A clicks 07:00 -> optimistic update shows booked locally -> POST to server succeeds (201)
     c. User B clicks 07:00 -> optimistic update shows booked locally -> POST to server returns 409 (slot already booked by A)
     d. User B's error handler calls triggerSync()
     e. triggerSync fetches server truth (shows A's booking at 07:00)
     f. User B's local state replaced with server state (A's booking appears, B's optimistic booking disappears)
     g. Maximum delay: near-instant (triggerSync is immediate on error)
   - If User B does nothing and just waits: next poll (within 7 seconds) replaces state anyway

7. **Polling vs Initial Load**
   - Initial load: Fetches bookings on app startup, sets loading=true during fetch, shows loading state
   - Polling: Background refresh, NO loading state change, seamless replacement
   - Both use the same GET /api/bookings endpoint
   - Both use the same state replacement mechanism

8. **Data Flow Diagram** (text-based, not Mermaid):
   ```
   App Load -> Initial Fetch -> Set Bookings State -> Start Polling Timer
                                                          |
                                                          v
                                                    [Every 7 seconds]
                                                          |
                                                          v
                                                   GET /api/bookings
                                                          |
                                                    +-----------+
                                                    | Success?  |
                                                    +-----------+
                                                   Yes |     | No
                                                       v     v
                                              Replace   Log warning
                                              local     Continue
                                              state     polling
   ```

Do NOT use React-specific terms (useState, useEffect, useRef, useCallback, hooks, component lifecycle). Describe as "application load", "background timer", "local state", etc.
  </action>
  <verify>
Verify the document by checking:
1. File exists and has 100+ lines
2. Polling interval (7000ms) documented
3. Error handling documented (non-fatal, no backoff)
4. Manual sync (triggerSync) documented with when it fires
5. Conflict detection scenario documented step-by-step
6. Initial load vs polling difference documented
7. No React-specific terminology (grep for useState, useEffect, useRef, useCallback, hook)
  </verify>
  <done>POLLING-SYNC.md exists with polling configuration, lifecycle, error handling, manual sync trigger, conflict detection scenario, and initial load vs polling comparison -- all technology-neutral.</done>
</task>

<task type="auto">
  <name>Task 2: Create STATE-MANAGEMENT.md (ARCH-04)</name>
  <files>.planning/phases/08-architecture-documentation/STATE-MANAGEMENT.md</files>
  <action>
Create a comprehensive state management document by reading src/hooks/useBookings.js, src/context/ConfigContext.jsx, src/App.jsx, src/utils/storage.js, src/hooks/useHourlyRefresh.js, and src/utils/time.js.

Document these sections:

1. **State Overview** -- What state exists in the application:

   a) Server State (persisted, shared across users):
      - Bookings: `{ [dateKey]: { [timeKey]: { user, duration } } }` -- stored in KV, synced via polling
      - Config: `{ slug, title, users[], createdAt }` -- stored in KV, loaded once at startup

   b) Client State (per-browser, not shared):
      - Current date: Date object for which day is being viewed
      - Week view toggle: boolean (day view vs week view)
      - Selected slot: slot object or null (which slot is being booked)
      - Selected user: string or null (during booking flow, which user is selected)
      - Focused slot index: integer (keyboard navigation position)
      - Selected booking: booking object or null (which booking is being edited in popup)
      - NSW timezone toggle: boolean (QLD vs NSW display)

   c) Derived State (computed from other state):
      - Slot status (available/booked/blocked): computed from bookings for the current date
      - Current hour available: computed from current time + bookings (for Book Now button)
      - Is slot past: computed from current time + slot hour
      - Display times: computed from base time + NSW toggle offset

   d) Persisted Client State:
      - Timezone preference: stored in localStorage key "cps-timezone-preference" (value: "NSW" or "QLD")
      - Loaded on app start, saved on toggle

2. **State Initialization Order** -- CRITICAL section:

   Step 1: App renders, timezone preference loaded from localStorage (sync, immediate)
   Step 2: Config loaded from API (async) -- GET /api/config
   Step 3: If config fails, fallback config used (app still works)
   Step 4: Bookings loaded from API (async) -- GET /api/bookings
   Step 5: Polling starts (7-second interval)
   Step 6: Hourly refresh timer starts (fires at each hour boundary)

   WHY ORDER MATTERS:
   - Config MUST load before bookings are usable (user validation requires config.users)
   - Bookings MUST load before polling makes sense (polling replaces state -- need initial state first)
   - Hourly refresh is independent (just needs current time)

3. **Optimistic Update Pattern** -- For ALL three operations:

   a) Create Booking:
      1. User selects slot + user + duration
      2. IMMEDIATELY add booking to local state: `bookings[date][time] = { user, duration }`
      3. UI updates instantly (user sees booking appear)
      4. Background: POST /api/bookings
      5. On success (201): No action needed (optimistic update was correct)
      6. On error (409 conflict, etc.): Set error state, call triggerSync()
      7. triggerSync fetches true server state, REPLACES local state (wrong booking disappears)

   b) Update Booking (change user or duration):
      1. User changes user or duration in popup
      2. IMMEDIATELY update local state: `bookings[date][time] = { ...current, ...updates }`
      3. UI updates instantly
      4. Background: PUT /api/bookings/update
      5. On success (200): No action needed
      6. On error (409 duration conflict, 404 not found): Set error, triggerSync()
      7. triggerSync replaces state (reverts to pre-update values)

   c) Delete Booking:
      1. User clicks delete
      2. IMMEDIATELY remove from local state: `delete bookings[date][time]`
      3. If date has no remaining bookings, remove date key
      4. UI updates instantly (booking disappears)
      5. Background: DELETE /api/bookings/update
      6. On success (200): No action needed
      7. On error (404): Set error, triggerSync()
      8. triggerSync replaces state (deleted booking reappears if server still has it)

   KEY PRINCIPLE: Optimistic updates make the app feel instant. Errors self-correct via sync. No complex CRDT or conflict resolution logic.

4. **State Triggers** -- What causes state to change:

   | Trigger | State Changed | Mechanism |
   |---------|---------------|-----------|
   | App load | config, bookings | API fetch |
   | Slot click | selectedSlot, selectedUser=null | User interaction |
   | User button click | selectedUser | User interaction |
   | Duration button click | bookings (optimistic), selectedSlot=null | Optimistic update + API |
   | Booking click | selectedBooking | User interaction |
   | Popup user change | bookings (optimistic) | Optimistic update + API |
   | Popup duration change | bookings (optimistic) | Optimistic update + API |
   | Popup delete | bookings (optimistic), selectedBooking=null | Optimistic update + API |
   | Popup close | selectedBooking=null | User interaction |
   | Panel cancel | selectedSlot=null, selectedUser=null | User interaction |
   | Poll tick | bookings (full replace) | Background timer |
   | Error on API call | error, bookings (via triggerSync) | Error handler |
   | Timezone toggle | useNSWTime, localStorage | User interaction |
   | Arrow key nav | currentDate or focusedSlotIndex | User interaction |
   | Week toggle | isWeekView | User interaction |
   | Hour boundary | Forces UI re-evaluation of past slots | Hourly timer |
   | Book Now click | selectedSlot (current hour), currentDate (today) | User interaction |

5. **Slot Status Calculation** -- How slot status is derived:

   For each slot in the time grid, status is computed:
   1. Check if slot has a direct booking at `bookings[dateKey][timeKey]` -> status: "booked"
   2. Check if slot is blocked by a multi-hour booking starting earlier:
      - Iterate all bookings for the date
      - For each booking, calculate occupied range: startHour to startHour + duration
      - If current slot's hour falls INSIDE that range (not at start) -> status: "blocked"
      - Include reference to the blocking booking
   3. If neither -> status: "available"
   4. Separately: check if slot is past (current time > slot end hour) for visual dimming

   canBook() function: Checks ALL slots in proposed duration range. Returns false if ANY is booked or blocked.
   canChangeDuration() function: Same check but EXCLUDES current booking's own slots.

6. **Hourly Refresh Mechanism**:
   - Timer calculates exact milliseconds until next hour boundary
   - Fires at HH:00:00.000 (accounts for minutes, seconds, milliseconds)
   - Forces UI re-evaluation of which slots are "past"
   - Example: At 7:59:59, slot 7 AM is current. At 8:00:00.000, timer fires, slot 7 AM becomes past (greyed out)
   - Independent of polling (different concern)

7. **localStorage Persistence**:
   - Only timezone preference is persisted client-side
   - Key: "cps-timezone-preference"
   - Values: "NSW" or "QLD"
   - Default: QLD (false) if not set or on read error
   - Error handling: graceful fallback, errors logged but don't break app

Do NOT use React-specific terms. Use "application state", "local cache", "background process", "UI update", etc. Describe patterns, not React hooks.
  </action>
  <verify>
Verify the document by checking:
1. File exists and has 150+ lines
2. State categories documented (server, client, derived, persisted)
3. Initialization order documented with WHY order matters
4. Optimistic update pattern documented for all 3 operations (create, update, delete)
5. State triggers table includes all major triggers
6. Slot status calculation documented with multi-hour blocking logic
7. Hourly refresh documented
8. No React-specific terminology (grep for useState, useEffect, useCallback, useRef, hook, props, component, render)
  </verify>
  <done>STATE-MANAGEMENT.md exists with complete state inventory (server, client, derived, persisted), initialization order with dependency explanation, optimistic update pattern for all 3 CRUD operations with rollback, state triggers table, slot status calculation logic, hourly refresh mechanism, and localStorage persistence -- all technology-neutral.</done>
</task>

</tasks>

<verification>
Phase-level checks for this plan:
1. Both documents exist in .planning/phases/08-architecture-documentation/
2. POLLING-SYNC.md covers ARCH-03 (interval timing, triggers, conflict detection)
3. STATE-MANAGEMENT.md covers ARCH-04 (what state exists, how it flows, what triggers updates)
4. Documents cross-reference each other (polling updates state, optimistic updates trigger sync)
5. No React-specific terminology in either document
6. Conflict detection scenario documented end-to-end (two users, same slot)
7. Optimistic update + rollback pattern documented for create, update, and delete
</verification>

<success_criteria>
- POLLING-SYNC.md completely documents the real-time sync mechanism including timing, error handling, manual sync, and conflict resolution
- STATE-MANAGEMENT.md completely documents all application state, initialization order, update patterns, and triggers
- A Rails developer reading these two documents would understand exactly how data flows through the application and how multi-user synchronization works
- ARCH-03 and ARCH-04 requirements fully satisfied
- Both documents are technology-neutral with no React-specific terminology
</success_criteria>

<output>
After completion, create `.planning/phases/08-architecture-documentation/08-03-SUMMARY.md`
</output>
